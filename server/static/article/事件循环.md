# 事件循环

浏览器：一个应用程序，本质上是一个运行js的环境，也称为宿主环境

执行引擎：浏览器内核中的一个模块，主要用于执行js代码，最著名的就是v8引擎

进程与线程：

- 进程：操作系统在启动一个应用程序时，会给他分配一个进程，本质上是一块独立的内存空间，
- 线程：一个应用程序在运行的过程中，可能出现很多任务（监听事件，渲染页面，网络通信，执行js代码）每个相对独立任务，会分配到某个线程执行，这些线程与线程之间共享内存

单线程：浏览器执行js的时候，只有一个线程在执行

异步：js是一个基于异步的语言，某些函数不会立即执行，需要等到某个时机成熟后才会执行，该函数叫做异步函数 node.js选择js作为其开发语言，主要是js支持异步。



遇到计时异步事件：执行线程通知计时线程，到时间了之后给执行队列，等执行线程执行完同步代码就会来事件队列来拿事件执行。

遇到监听异步事件：执行线程通知事件监听线程，到了之后给执行队列，等执行线程执行完同步代码就会来事件队列来拿事件执行

执行栈：

![image-20200624203504106](../assets/image-20200624203504106.png)

递归主要是消耗执行栈，递归就会不断撑满执行栈，导致内存溢出





执行栈  执行上下文 全局上下文

js执行代码过程中，首先会向执行栈中加入全局上下文，然后遇到函数调用，就往执行栈顶部加入一个函数执行上下文，如果函数运行完了，这个函数的执行上下文就出栈



执行栈溢出：典型的就是斐波那契数列，原因就是代码执行过程中，首先会向执行栈中加入全局执行上下文，然后运行斐波那契函数，把斐波那契函数加入执行栈中，由于是递归，就有不断的往执行栈中加入函数，当计算的数比较大的时候，执行栈就会溢出，所以递归主要消耗的是执行栈，而一般的死循环不回答导致执行栈溢出



### 事件循环本质：执行栈 =》webapi（计时器线程等浏览器其他线程）=》事件队列 =》执行栈

![image-20200912185253227](../assets/image-20200912185253227.png)



### 事件队列：（类似两个数组）

- 宏队列
- 微队列（执行栈清空后会优先去取微队列中的事件）



## 浏览器的线程（五个线程）

**1、JS执行引擎：负责执行js代码（单线程，平时看到的）**
**2、渲染线程：负责渲染页面**
**3、计时器线程：负责计时**
**4、事件监听线程：负责监听事件**
**5、http网络线程：负责网络通信**

**事件队列**：一块内存空间，用于存放执行时机到达的异步函数。**当js引擎空闲（执行栈没有可执行的上下文）**，它才会从事件队列中拿出第一个函数来执行 
（执行过程是这样的，首先js按执行栈顺序执行代码，遇到异步代码就放到宿主环境中，等执行时机到达的异步函数就会被放到事件对列，等到js把同步代码都执行完了之后，执行栈里面没有可执行的函数等，才会去把事件对列里面的函数给执行了。这就构成了事件循环）

事件循环:是指函数在执行栈，宿主线程，事件队列中的循环移动（执行）

js在执行一个函数时，当触发了某个事件时，这不会打断这个函数的执行，它会等到执行栈空了才会去执行这个函数。